<?php/* License & ContactLicense:   Copyright (c) 2011 Raymond Ellis   This software is provided 'as-is', without any express or implied   warranty. In no event will the authors be held liable for any damages   arising from the use of this software.   Permission is granted to anyone to use this software for any purpose,   including commercial applications, and to alter it and redistribute it   freely, subject to the following restrictions:       1. The origin of this software must not be misrepresented; you must not           claim that you wrote the original software. If you use this software           in a product, an acknowledgment in the product documentation would be           appreciated but is not required.       2. Altered source versions must be plainly marked as such, and must not be           misrepresented as being the original software.       3. This notice may not be removed or altered from any source           distribution.Contact:   Raymond Ellis   Email: RaymondEllis*live.com   Website: https://sites.google.com/site/raymondellis89/*/	class sdStyle{		const None = 0;		const NoStyle = 1;/* NoStyle means everything will be in one long line. */		const Whitesmiths=2;		const GNU=3;		const BSD_Allman=4;		const K_R=5;		const GroupsOnNewLine=6;	}		class Info{		const sdVersion=1.1;		const sdFileVersion=3;	}		$AllowEqualsInValue=false;	$AllowSemicolonInValue=true;		class sdGroup {		var $name;		var $grps=array();		var $props=array();						var $BraceStyle=sdStyle::None; /* 0=none 1=BSD_Allman 2=? */		var $Tab="\t";				function __construct($name){			$this->name = $name;		}				function FromString($Data){			$index=0;			return $this->FromStringBase(true, $Data, $index);		}		function FromStringBase($IsFirst, $Data, &$Index)		{			if ($Data==""){return "Data is empty!";}						$Results="";			$State=0; /*0=Nothing 1=InProperty 2=InComment*/						$StartIndex=$Index;	/*The start of the group.*/			$ErrorIndex=0; /*Used for error handling.*/			$tName=""; /*Temp group or propery name.*/			$tValue=""; /*same but for value.*/			GLOBAL $AllowSemicolonInValue;						while ($Index < strlen($Data)) {				$chr=$Data[$Index];								switch ($State){					case 0: /*In nothing*/						switch ($chr){							case "=":								$ErrorIndex=$Index;								$State=1; /*We are now in state 1(in property)*/								break;															case ";":								if (trim($tName=="")){									$Results .= " #Found end of property but no name&value at index: " . $Index . " Could need AllowSemicolonInValue enabled.";								} else {									$this->props[]= new sdprop(trim($tName), "");								}								$tName="";								$tValue="";								break;															case "{": /*New group*/								$Index++;								$tmpG =& new sdGroup(trim($tName));								$Results .= $tmpG->FromStringBase(false, $Data, $Index);								$this->grps[]=& $tmpG;								$tName="";								break;															case "}": /*End of current group*/								return $Results;															case "*": /* start of Comment */								if ($Index-1>=0){									if ($Data[$Index-1]=="/"){										$tName="";										$State=2;										$ErrorIndex=$Index;																			}else{$tName .= $chr;}								}else{$tName .= $chr;}								break;															default:								$tName .= $chr;								break;						}												break;					case 1: /*In property.*/						if ($chr==";"){							if ($AllowSemicolonInValue and $Index+1<strlen($Data) AND $Data[$Index+1]==";"){								$Index++;								$tValue .=$chr;							} else {								$this->props[]= new sdprop(trim($tName), $tValue);								$tName="";								$tValue="";								$State=0;							}													}elseif( $chr=="="){							if ($AllowEqualsInValue==true){								$tValue .= $chr;							}else{								$Results .= "  #Missing end of property " . trim($tName) . " at index: " . $ErrorIndex;                                $ErrorIndex = $Index;                                $tName = "";                                $tValue = "";							}						}else{							$tValue .=$chr;						}						break;											case 2; /*In comment*/						if ($chr=="/" and $Data[$Index-1]=="*"){							$State=0;						}						break;				}				$Index++;			}						if ($State==1){				$Results .= " #Missing end of property " . trim($tName) . " at index: " . $ErrorIndex;            }elseif ($State == 2){                $Results .= " #Missing end of comment " . trim($tName) . " at index: " . $ErrorIndex;            }elseif ($IsFirst==false){                $Results .= "  #Missing end of group " . trim($tName) . " at index: " . $StartIndex;            }			return $Results;		} /*end fromstring function.*/						function ToString($AddVersion){			return $this->ToStringBase(true, -1, $AddVersion, $this->BraceStyle);		}		function ToStringBase($IsFirst, $TabCount, $AddVersion, $braceStyle)		{			if (!isset($this->grp) and !isset($this->props)){return "";}			if ($TabCount < -1){$TabCount=-2;} /*Tab count Below -1 means use zero tabs.*/						if ($this->BraceStyle<>sdStyle::None){$braceStyle=$this->BraceStyle;}			if ($braceStyle==sdStyle::None){$braceStyle=sdStyle::BSD_Allman;}						$tmp="";						if($AddVersion==true){				$tmp="SimpleD{Version=".sdInfo::Version.";FormatVersion=".sdInfo::FileVersion.";}";			}						/* Name and start of group. Name{ */			if ($IsFirst==false){				switch ($braceStyle){					case sdStyle::NoStyle:					case sdStyle::K_R:						$tmp .=$this->name."{";						break;											case sdStyle::Whitesmiths:						$tmp .=$this->name."\n".$this->GetTabs($TabCount+1)."{";						break;											case sdStyle::BSD_Allman:						$tmp .=$this->name."\n".$this->GetTabs($TabCount)."{";						break;											case sdStyle::GNU:						$tmp .=$this->name."\n".$this->GetTabs($TabCount)."  {";						break;										case sdStyle::GroupsOnNewLine:						$tmp .="\n".$this->GetTabs($TabCount-1).$this->name."{";						break;				}			}						/* Groups and properties */			switch ($braceStyle){				case sdStyle::NoStyle:				case sdStyle::GroupsOnNewLine:					if(isset($this->props)){						for ($i = 0; $i <count($this->props); $i++){							$tmp .=$this->props[$i]->toString();						}					}					if(isset($this->grps)){						for ($i = 0; $i <count($this->grps); $i++){							$tmp .=$this->grps[$i]->ToStringBase(false, $TabCount+1, false, $braceStyle);						}					}					break;									case sdStyle::Whitesmiths:				case sdStyle::BSD_Allman:				case sdStyle::K_R:				case sdStyle::GNU:					if(isset($this->props)){						for ($i = 0; $i <count($this->props); $i++){							$tmp .="\n".$this->GetTabs($TabCount+1).$this->props[$i]->toString();						}					}					if(isset($this->grps)){						for ($i = 0; $i <count($this->grps); $i++){							$tmp .="\n".$this->GetTabs($TabCount+1).$this->grps[$i]->ToStringBase(false, $TabCount+1, false, $braceStyle);						}					}					break;			}									/* End of group } */			if ($IsFirst==false){				switch ($braceStyle){					case sdStyle::NoStyle:					case sdStyle::GroupsOnNewLine:						$tmp .="}";						break;											case sdStyle::Whitesmiths:						$tmp .="\n".$this->GetTabs($TabCount+1)."}";						break;											case sdStyle::BSD_Allman:					case sdStyle::K_R:						$tmp .="\n".$this->GetTabs($TabCount)."}";						break;											case sdStyle::GNU:						$tmp .="\n".$this->GetTabs($TabCount)."  }";						break;				}			}						return $tmp;		}				private function GetTabs($Count){			if($Count<1){return "";}			return str_repeat($this->Tab,$Count);		}			}		class sdprop {		var $name;		var $value;		function __construct($name, $value){			$this->name=$name;			$this->value=$value;		}		public function toString(){			if($this->value==""){return $this->name.";";}						GLOBAL $AllowSemicolonInValue;			if($AllowSemicolonInValue){				$tmpValue=str_replace(";",";;",$this->value);				return $this->name."=".$tmpValue.";";			} else {				return $this->name . "=" . $this->value . ";";			}		}	}	?>